


1. 框架结构
	1.1 rts_web_relation.pdf
	1.2 app_server.pdf 	

2. 代码结构

	代码主要分为两个独立部分 ,  一个是用户消息(来自客户端) 处理循环 , 另一个时服务消息处理循环(后端推送) . 
两个循环分别在独立的线程中运行, 所以要注意下线程通信以及竞争条件 .
	

	2.1 线程模型
		2.1.1 用户消息循环线程是一个 : websocket server 使用tornado.web.websocketserver 
		2.1.2 服务消息循环 时接受后端服务的消息循环 .  轮循redis 消息队列  (list key为: queue:rtserver) , 分发处理 .

	2.2 模块关系
		可参考框架app_server 结构 .
		2.2.1 设计结构
			参考realtime_service_internal.pdf
			图中<realtime_service_internal.pdf>
			注解:
				1. 客户端请求连接握手
				2. websocket server 将连接打开消息发送给user manager 
				3. user manager 验证用户sessionid 是合法 , 获取用户信息, 生成user agent
				4. useragent 校验成功消息打包给客户端 , 发送了用户实例id (区分同用户多连接) , 连接建立成功
				5. 客户端发起一个实时应用(如渲染行情)请求
				6. websocket 收到消息报告给user manager
				7. user manager 分发消息给对应实时应用消息类型处理器(图表渲染消息处理器 , MyChartMsgHandler)
				8. 图表渲染消息处理器(分析渲染请求 , (第一次创建) 用户行情处理部件(modules MyCharAgent , QuoteListener)
				9. 用户处理部件( QuoteListener ) 从 后端服务 ( 行情中心 QuoteCenter )  取/订阅 用户指定数据 (行情)
				10. 后端数据源 (数据生产者 , 行情转发器 ,  模拟 TestQuoteSource ) 将数据(最新行情信)放入rts 消息队列(类型为行情)
				11. service dispatcher (ServiceDispatcher) 从消息队列取到数据请求/订阅者需要的数据(行情信息) 
				12  分发器识别数据类型 分发给 对应类型服务 ( QuoteCenter)  , 对一个服务将数据发给请求者部件 (QuoteListener)
				13. 请求者部件 (QuoteListenr) 拿到数据调用数据分析计算服务 , 计算出用户需要的数据 , 在调用绘制服务(MyChartAgent) 绘制推送
				14. user agent 推送上层的消息 , 将消息打包为制定的格式 . 发送给客户端
				15. 客户端收到消息 , 解析消息类型, 得到对应的客户端消息处理器, 绘制图形 .

		2.2.2 目录结构

			rtserver/   			# 实时服务工程根目录
				├── base			# 地层基础 , 包含websocket server
				├── bootstrap 	# 初始化引导代码 , 用于预处理
				├── handlers		# 用户消息处理 , 实时应用客户端消息处理部分
				├── modules		# 实时应用 , 用户逻辑处理部分 (一般不发送消息, 而是专注后端逻辑)
				├── service		# 后端服务消息框架 , 可以监听需要处理的后端消息 . 自动分发给自定义服务 
				├── test			# 测试使用
				└── user			# 用户抽象模块 , 提供用户消息分发框架

		2.2.3 客户端和websocket server 协议
			json 格式 , 具体协议参考docs目录下的csprotocols.readme.md						

	2.3 结构原则
		2.3.1 代码按照功能类分目录放置 .
		2.3.2 模块间通信关系使用统一风格接口 (参考服务: django_site , quote_center , 交互应用: MychartMsgHandler  )
		2.3.3 符合PEP 8 规范 , 符合RSS python编码规范 .

3. 代码实现
	3.1 服务
		3.1.1 服务消息
			rtserver 定制了一个redis 消息队列 , 键值名字为queue:rtserver , 每条消息的格式为: {type:'', src:'', data:''}  定义在(ServiceMessageQueue) 

		3.1.2 服务处理器
			收到服务消息后 , 根据注册的处理器, 取出消息type 分发到对应的消息处理器 .  见(ServiceMessageDispatcher)
			每个service message handler 都要从ServiceMsgHandler继承 , 实现__call__方法 , 以及__init__注册自己的消息类型 ,这样后端发送的消息这个handler就能受到了 .
			可以参考DjangoSiteMsgHandler 和 quote_center 这两个服务的实现 .
			

		3.1.3 同步
			服务消息处理在一个线程中 , 假如一个服务消息处理器要访问用户时 , 可以通过UserManager.instance().get_users(***) 获取用户并推送消息 .
			单要注意用户某些部分属性可能在其他线程生灭 , 注意锁资源 ( 可参考quote_center 和 quote_listener module 的实现).

	3.2 用户
		3.2.1 用户消息
			wss 线程从websocket server 收到用户连接后会自动建立一个用户代理 (自动验证权限) .  
			客户端提供了相应的JS库 , 所以用户消息格式也是固定的使用json交换 , 格式为 : {type: 'type' , data: 'data'} , type 为用户注册的消息处理器 , 获得type后 ,
		UserManager会找到用户代理, 根据type分发给相应的(user message) handler  (在handler目录下) .

		3.2.2 用户消息处理器
			当要实现一个与客户端实时交互的新功能时,  可以新定一个消息类型 , 这是需要在客户端和服务器分别注册这种类型的消息处理器 .
		服务端用户消息处理器必须继承自:BaseUserMsgHandler , 实现on_useragent_msg , 处理消息 , 并在开始注册 .


	3.3 模块逻辑
		
		3.3.1 用户模块
			实时应用一个特点是有状态 , 用户当前时在线的, 所以可以随时推送消息 .  很多实时应用共同存在时, 最好能根据功能分离, 使其关系清晰, 便于理解和调试.
		modules 是一个胶水层设计 ,  一个module 一般是一个用户部件, 代表了一个新的实时功能 , 初始时这个部件不存在 , 在相关实时应用收到消息后创建此module , 
		在应用收到用户下线消息时, 删除此module , 这个module 是用户消息和后端服务的连接器 , module会提供一些功能给前端调用后端服务,  
		也提供一些功能给后端 操作用户push消息或者使用其他module , 

		3.3.2 参考实现
			MyChartAgent , QuoteListener 是两个典型的module实现 , 其中MyChartAgen 代表了一个用户绘制图表部件,   当绘制系统要求绘制行情时, 
		这个部件会调用QuoteListener	获取历史行情或者订阅实时行情, QuoteCenter 从后端行情转发器收到行情消息时, 会将行情消息转发给QuoteListener,
		QuoteListener 会调用计算功能 (待实现)  分析行情, 求出用户订阅行情的指标等具体数据, 然后将计算过后的数据调用MyChartAgent部件绘制图表, 
		绘制完成后将图表数据发送给客户端渲染, 此时客户端呈现了新的图形数据 .
			当用户需要对图表做交互操作需要新的指标支持时, 用户可以发送消息给MyChartMsgHandler , MyChartMsgHandler 解析请求, 调用QuoteListenr . 
		得到新的行情数据解析后发送给客户端 . 客户端图表代理处理新的消息, 渲染新图表 .

			
	3.4 工具
		3.4.1 引导初始化
			运行一开始即需要导入的模块 , 初始化环境, 预处理等.
			如导入基础配置 , 如需要django工程配置等 (使用redis_session 共享) .

		3.4.2 django session 共享
			支持在rtservice 中对用户连接权限验证, 保证连接的用户时合法用户 .

		3.4.3 redis 消息队列
			简单封装了redis list 作为一个消息队列 , 每个进程可以有一个自己的消息队列, 从队列中收取消息, 向其他进程消息队列推送消息 .

		3.4.4 gevent  非阻塞并发处理模型
			service 使用的时单线程消息循环处理, 所以单个消息处理时间会直接影响其他消息延时 , 所以在service处理器中禁止使用阻塞型调用 .

	3.5 可视化服务
		包含两个部分 , 交互消息处理 (MyChartMsgHandler)  和  绘图部件 (MyChartAgent) 以及客户端的绘图代理 ( 解析消息, 调用底层echarts / zrender)
		3.5.1 客户端库 
			在site 目录的 core / static / js / rtc 目录下提供了JS库 , 实现了MyCharts 对象 , 初始化传入 RTClient 即可, 调用request 可以请求行情绘图,  可以扩展其他方法绘制其他图表 (目前比较简单支持动态静态线图绘制).
		3.5.2 服务端 
			MyChartMsgHandler 在handlers 目录下 , 接受客户端mycahrts类型的消息 , 解析绘图请求 .
			对于绘图, 类型为行情的请求, 创建用户的绘图部件 和  行情监听部件  . 
			静态绘制, 则调用行情监听部件请求行情信息,  根据行情信息调用绘图部件绘制图形(线图) ,  推送给客户端绘制 .
			动态绘制 , 先发送初始化历史行情(按天计) , 然后行情监听部件会订阅行情中心 , 将自己挂载到行情中心的订阅列表中, 有新行情数据打来时,
			行情中心广播行情给订阅者 , 行情监听部件收到行情调用 图表绘制部件 更新图表 . 客户端就会自动更新 .
		
		3.4.3 计算
			具体行情,或者其他计算需求  由于和业务强相关 , 暂时只实现基础绘图流程 .
			业务计算比如行情分析 和 指标计算, 届时需要封装一个 QuoteAnalysis 的部件 , 该部件可以输入行情数据 , 输出计算结果(指标数据等) . 

4. 功能扩展
	4.1 实时交互应用
		如果新增协议, 则新增handler (目录)  的 xxxx_msg_handler , 参考mychart_msg_handler
		如果需要和后端维持状态: 则可以新增module , 参考 MyChartAgent , QuoteListener

	4.2 后端推送服务
		内置了直接的用户消息推送服务
		如果需要新增自定义后端服务, 则新增service(目录) 的xxx_service_msg_handler , 参考 QuoteCenter , DjangoSiteMsgHandler .


5. 一些需要注意的地方
	5.1 线程通信 
	5.2 竞争条件
	5.3 django 和 rtservice 的配置依赖
	5.4 非阻塞处理
	5.5 消息类型唯一性检查 , 注意报错信息


