// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mongo.proto

#ifndef PROTOBUF_mongo_2eproto__INCLUDED
#define PROTOBUF_mongo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace dcorm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mongo_2eproto();
void protobuf_AssignDesc_mongo_2eproto();
void protobuf_ShutdownFile_mongo_2eproto();

class MongoFindEx;
class MongoRemoveEx;
class MongoOPReq;
class MongoOPRsp;
class MongoORM;

enum MongoOP {
  MONGO_OP_CMD = 0,
  MONGO_OP_FIND = 1,
  MONGO_OP_UPDATE = 2,
  MONGO_OP_INSERT = 3,
  MONGO_OP_DELETE = 4,
  MONGO_OP_COUNT = 5
};
bool MongoOP_IsValid(int value);
const MongoOP MongoOP_MIN = MONGO_OP_CMD;
const MongoOP MongoOP_MAX = MONGO_OP_COUNT;
const int MongoOP_ARRAYSIZE = MongoOP_MAX + 1;

const ::google::protobuf::EnumDescriptor* MongoOP_descriptor();
inline const ::std::string& MongoOP_Name(MongoOP value) {
  return ::google::protobuf::internal::NameOfEnum(
    MongoOP_descriptor(), value);
}
inline bool MongoOP_Parse(
    const ::std::string& name, MongoOP* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MongoOP>(
    MongoOP_descriptor(), name, value);
}
// ===================================================================

class MongoFindEx : public ::google::protobuf::Message {
 public:
  MongoFindEx();
  virtual ~MongoFindEx();

  MongoFindEx(const MongoFindEx& from);

  inline MongoFindEx& operator=(const MongoFindEx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MongoFindEx& default_instance();

  void Swap(MongoFindEx* other);

  // implements Message ----------------------------------------------

  MongoFindEx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MongoFindEx& from);
  void MergeFrom(const MongoFindEx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string sort = 1;
  inline int sort_size() const;
  inline void clear_sort();
  static const int kSortFieldNumber = 1;
  inline const ::std::string& sort(int index) const;
  inline ::std::string* mutable_sort(int index);
  inline void set_sort(int index, const ::std::string& value);
  inline void set_sort(int index, const char* value);
  inline void set_sort(int index, const char* value, size_t size);
  inline ::std::string* add_sort();
  inline void add_sort(const ::std::string& value);
  inline void add_sort(const char* value);
  inline void add_sort(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sort() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sort();

  // repeated string projection = 2;
  inline int projection_size() const;
  inline void clear_projection();
  static const int kProjectionFieldNumber = 2;
  inline const ::std::string& projection(int index) const;
  inline ::std::string* mutable_projection(int index);
  inline void set_projection(int index, const ::std::string& value);
  inline void set_projection(int index, const char* value);
  inline void set_projection(int index, const char* value, size_t size);
  inline ::std::string* add_projection();
  inline void add_projection(const ::std::string& value);
  inline void add_projection(const char* value);
  inline void add_projection(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& projection() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_projection();

  // optional int32 skip = 3;
  inline bool has_skip() const;
  inline void clear_skip();
  static const int kSkipFieldNumber = 3;
  inline ::google::protobuf::int32 skip() const;
  inline void set_skip(::google::protobuf::int32 value);

  // optional int32 limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dcorm.MongoFindEx)
 private:
  inline void set_has_skip();
  inline void clear_has_skip();
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sort_;
  ::google::protobuf::RepeatedPtrField< ::std::string> projection_;
  ::google::protobuf::int32 skip_;
  ::google::protobuf::int32 limit_;
  friend void  protobuf_AddDesc_mongo_2eproto();
  friend void protobuf_AssignDesc_mongo_2eproto();
  friend void protobuf_ShutdownFile_mongo_2eproto();

  void InitAsDefaultInstance();
  static MongoFindEx* default_instance_;
};
// -------------------------------------------------------------------

class MongoRemoveEx : public ::google::protobuf::Message {
 public:
  MongoRemoveEx();
  virtual ~MongoRemoveEx();

  MongoRemoveEx(const MongoRemoveEx& from);

  inline MongoRemoveEx& operator=(const MongoRemoveEx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MongoRemoveEx& default_instance();

  void Swap(MongoRemoveEx* other);

  // implements Message ----------------------------------------------

  MongoRemoveEx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MongoRemoveEx& from);
  void MergeFrom(const MongoRemoveEx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 limit = 1;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 1;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dcorm.MongoRemoveEx)
 private:
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 limit_;
  friend void  protobuf_AddDesc_mongo_2eproto();
  friend void protobuf_AssignDesc_mongo_2eproto();
  friend void protobuf_ShutdownFile_mongo_2eproto();

  void InitAsDefaultInstance();
  static MongoRemoveEx* default_instance_;
};
// -------------------------------------------------------------------

class MongoOPReq : public ::google::protobuf::Message {
 public:
  MongoOPReq();
  virtual ~MongoOPReq();

  MongoOPReq(const MongoOPReq& from);

  inline MongoOPReq& operator=(const MongoOPReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MongoOPReq& default_instance();

  void Swap(MongoOPReq* other);

  // implements Message ----------------------------------------------

  MongoOPReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MongoOPReq& from);
  void MergeFrom(const MongoOPReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string q = 1;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 1;
  inline const ::std::string& q() const;
  inline void set_q(const ::std::string& value);
  inline void set_q(const char* value);
  inline void set_q(const char* value, size_t size);
  inline ::std::string* mutable_q();
  inline ::std::string* release_q();
  inline void set_allocated_q(::std::string* q);

  // optional string u = 2;
  inline bool has_u() const;
  inline void clear_u();
  static const int kUFieldNumber = 2;
  inline const ::std::string& u() const;
  inline void set_u(const ::std::string& value);
  inline void set_u(const char* value);
  inline void set_u(const char* value, size_t size);
  inline ::std::string* mutable_u();
  inline ::std::string* release_u();
  inline void set_allocated_u(::std::string* u);

  // optional string cmd = 3;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 3;
  inline const ::std::string& cmd() const;
  inline void set_cmd(const ::std::string& value);
  inline void set_cmd(const char* value);
  inline void set_cmd(const char* value, size_t size);
  inline ::std::string* mutable_cmd();
  inline ::std::string* release_cmd();
  inline void set_allocated_cmd(::std::string* cmd);

  // optional .dcorm.MongoFindEx find = 4;
  inline bool has_find() const;
  inline void clear_find();
  static const int kFindFieldNumber = 4;
  inline const ::dcorm::MongoFindEx& find() const;
  inline ::dcorm::MongoFindEx* mutable_find();
  inline ::dcorm::MongoFindEx* release_find();
  inline void set_allocated_find(::dcorm::MongoFindEx* find);

  // optional .dcorm.MongoRemoveEx remove = 5;
  inline bool has_remove() const;
  inline void clear_remove();
  static const int kRemoveFieldNumber = 5;
  inline const ::dcorm::MongoRemoveEx& remove() const;
  inline ::dcorm::MongoRemoveEx* mutable_remove();
  inline ::dcorm::MongoRemoveEx* release_remove();
  inline void set_allocated_remove(::dcorm::MongoRemoveEx* remove);

  // @@protoc_insertion_point(class_scope:dcorm.MongoOPReq)
 private:
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_u();
  inline void clear_has_u();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_find();
  inline void clear_has_find();
  inline void set_has_remove();
  inline void clear_has_remove();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* q_;
  ::std::string* u_;
  ::std::string* cmd_;
  ::dcorm::MongoFindEx* find_;
  ::dcorm::MongoRemoveEx* remove_;
  friend void  protobuf_AddDesc_mongo_2eproto();
  friend void protobuf_AssignDesc_mongo_2eproto();
  friend void protobuf_ShutdownFile_mongo_2eproto();

  void InitAsDefaultInstance();
  static MongoOPReq* default_instance_;
};
// -------------------------------------------------------------------

class MongoOPRsp : public ::google::protobuf::Message {
 public:
  MongoOPRsp();
  virtual ~MongoOPRsp();

  MongoOPRsp(const MongoOPRsp& from);

  inline MongoOPRsp& operator=(const MongoOPRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MongoOPRsp& default_instance();

  void Swap(MongoOPRsp* other);

  // implements Message ----------------------------------------------

  MongoOPRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MongoOPRsp& from);
  void MergeFrom(const MongoOPRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const char* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  inline void set_allocated_result(::std::string* result);

  // optional string error = 3;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 3;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:dcorm.MongoOPRsp)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* result_;
  ::std::string* error_;
  ::google::protobuf::int32 status_;
  friend void  protobuf_AddDesc_mongo_2eproto();
  friend void protobuf_AssignDesc_mongo_2eproto();
  friend void protobuf_ShutdownFile_mongo_2eproto();

  void InitAsDefaultInstance();
  static MongoOPRsp* default_instance_;
};
// -------------------------------------------------------------------

class MongoORM : public ::google::protobuf::Message {
 public:
  MongoORM();
  virtual ~MongoORM();

  MongoORM(const MongoORM& from);

  inline MongoORM& operator=(const MongoORM& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MongoORM& default_instance();

  void Swap(MongoORM* other);

  // implements Message ----------------------------------------------

  MongoORM* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MongoORM& from);
  void MergeFrom(const MongoORM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .dcorm.MongoOP op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::dcorm::MongoOP op() const;
  inline void set_op(::dcorm::MongoOP value);

  // required string db = 2;
  inline bool has_db() const;
  inline void clear_db();
  static const int kDbFieldNumber = 2;
  inline const ::std::string& db() const;
  inline void set_db(const ::std::string& value);
  inline void set_db(const char* value);
  inline void set_db(const char* value, size_t size);
  inline ::std::string* mutable_db();
  inline ::std::string* release_db();
  inline void set_allocated_db(::std::string* db);

  // optional string coll = 3;
  inline bool has_coll() const;
  inline void clear_coll();
  static const int kCollFieldNumber = 3;
  inline const ::std::string& coll() const;
  inline void set_coll(const ::std::string& value);
  inline void set_coll(const char* value);
  inline void set_coll(const char* value, size_t size);
  inline ::std::string* mutable_coll();
  inline ::std::string* release_coll();
  inline void set_allocated_coll(::std::string* coll);

  // optional .dcorm.MongoOPReq req = 4;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 4;
  inline const ::dcorm::MongoOPReq& req() const;
  inline ::dcorm::MongoOPReq* mutable_req();
  inline ::dcorm::MongoOPReq* release_req();
  inline void set_allocated_req(::dcorm::MongoOPReq* req);

  // optional .dcorm.MongoOPRsp rsp = 5;
  inline bool has_rsp() const;
  inline void clear_rsp();
  static const int kRspFieldNumber = 5;
  inline const ::dcorm::MongoOPRsp& rsp() const;
  inline ::dcorm::MongoOPRsp* mutable_rsp();
  inline ::dcorm::MongoOPRsp* release_rsp();
  inline void set_allocated_rsp(::dcorm::MongoOPRsp* rsp);

  // optional bytes cb = 6;
  inline bool has_cb() const;
  inline void clear_cb();
  static const int kCbFieldNumber = 6;
  inline const ::std::string& cb() const;
  inline void set_cb(const ::std::string& value);
  inline void set_cb(const char* value);
  inline void set_cb(const void* value, size_t size);
  inline ::std::string* mutable_cb();
  inline ::std::string* release_cb();
  inline void set_allocated_cb(::std::string* cb);

  // @@protoc_insertion_point(class_scope:dcorm.MongoORM)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_db();
  inline void clear_has_db();
  inline void set_has_coll();
  inline void clear_has_coll();
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_rsp();
  inline void clear_has_rsp();
  inline void set_has_cb();
  inline void clear_has_cb();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* db_;
  ::std::string* coll_;
  ::dcorm::MongoOPReq* req_;
  ::dcorm::MongoOPRsp* rsp_;
  ::std::string* cb_;
  int op_;
  friend void  protobuf_AddDesc_mongo_2eproto();
  friend void protobuf_AssignDesc_mongo_2eproto();
  friend void protobuf_ShutdownFile_mongo_2eproto();

  void InitAsDefaultInstance();
  static MongoORM* default_instance_;
};
// ===================================================================


// ===================================================================

// MongoFindEx

// repeated string sort = 1;
inline int MongoFindEx::sort_size() const {
  return sort_.size();
}
inline void MongoFindEx::clear_sort() {
  sort_.Clear();
}
inline const ::std::string& MongoFindEx::sort(int index) const {
  // @@protoc_insertion_point(field_get:dcorm.MongoFindEx.sort)
  return sort_.Get(index);
}
inline ::std::string* MongoFindEx::mutable_sort(int index) {
  // @@protoc_insertion_point(field_mutable:dcorm.MongoFindEx.sort)
  return sort_.Mutable(index);
}
inline void MongoFindEx::set_sort(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:dcorm.MongoFindEx.sort)
  sort_.Mutable(index)->assign(value);
}
inline void MongoFindEx::set_sort(int index, const char* value) {
  sort_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoFindEx.sort)
}
inline void MongoFindEx::set_sort(int index, const char* value, size_t size) {
  sort_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoFindEx.sort)
}
inline ::std::string* MongoFindEx::add_sort() {
  return sort_.Add();
}
inline void MongoFindEx::add_sort(const ::std::string& value) {
  sort_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dcorm.MongoFindEx.sort)
}
inline void MongoFindEx::add_sort(const char* value) {
  sort_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dcorm.MongoFindEx.sort)
}
inline void MongoFindEx::add_sort(const char* value, size_t size) {
  sort_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dcorm.MongoFindEx.sort)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MongoFindEx::sort() const {
  // @@protoc_insertion_point(field_list:dcorm.MongoFindEx.sort)
  return sort_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MongoFindEx::mutable_sort() {
  // @@protoc_insertion_point(field_mutable_list:dcorm.MongoFindEx.sort)
  return &sort_;
}

// repeated string projection = 2;
inline int MongoFindEx::projection_size() const {
  return projection_.size();
}
inline void MongoFindEx::clear_projection() {
  projection_.Clear();
}
inline const ::std::string& MongoFindEx::projection(int index) const {
  // @@protoc_insertion_point(field_get:dcorm.MongoFindEx.projection)
  return projection_.Get(index);
}
inline ::std::string* MongoFindEx::mutable_projection(int index) {
  // @@protoc_insertion_point(field_mutable:dcorm.MongoFindEx.projection)
  return projection_.Mutable(index);
}
inline void MongoFindEx::set_projection(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:dcorm.MongoFindEx.projection)
  projection_.Mutable(index)->assign(value);
}
inline void MongoFindEx::set_projection(int index, const char* value) {
  projection_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoFindEx.projection)
}
inline void MongoFindEx::set_projection(int index, const char* value, size_t size) {
  projection_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoFindEx.projection)
}
inline ::std::string* MongoFindEx::add_projection() {
  return projection_.Add();
}
inline void MongoFindEx::add_projection(const ::std::string& value) {
  projection_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dcorm.MongoFindEx.projection)
}
inline void MongoFindEx::add_projection(const char* value) {
  projection_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dcorm.MongoFindEx.projection)
}
inline void MongoFindEx::add_projection(const char* value, size_t size) {
  projection_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dcorm.MongoFindEx.projection)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MongoFindEx::projection() const {
  // @@protoc_insertion_point(field_list:dcorm.MongoFindEx.projection)
  return projection_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MongoFindEx::mutable_projection() {
  // @@protoc_insertion_point(field_mutable_list:dcorm.MongoFindEx.projection)
  return &projection_;
}

// optional int32 skip = 3;
inline bool MongoFindEx::has_skip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MongoFindEx::set_has_skip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MongoFindEx::clear_has_skip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MongoFindEx::clear_skip() {
  skip_ = 0;
  clear_has_skip();
}
inline ::google::protobuf::int32 MongoFindEx::skip() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoFindEx.skip)
  return skip_;
}
inline void MongoFindEx::set_skip(::google::protobuf::int32 value) {
  set_has_skip();
  skip_ = value;
  // @@protoc_insertion_point(field_set:dcorm.MongoFindEx.skip)
}

// optional int32 limit = 4;
inline bool MongoFindEx::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MongoFindEx::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MongoFindEx::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MongoFindEx::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 MongoFindEx::limit() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoFindEx.limit)
  return limit_;
}
inline void MongoFindEx::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:dcorm.MongoFindEx.limit)
}

// -------------------------------------------------------------------

// MongoRemoveEx

// optional int32 limit = 1;
inline bool MongoRemoveEx::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MongoRemoveEx::set_has_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MongoRemoveEx::clear_has_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MongoRemoveEx::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 MongoRemoveEx::limit() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoRemoveEx.limit)
  return limit_;
}
inline void MongoRemoveEx::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:dcorm.MongoRemoveEx.limit)
}

// -------------------------------------------------------------------

// MongoOPReq

// optional string q = 1;
inline bool MongoOPReq::has_q() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MongoOPReq::set_has_q() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MongoOPReq::clear_has_q() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MongoOPReq::clear_q() {
  if (q_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_->clear();
  }
  clear_has_q();
}
inline const ::std::string& MongoOPReq::q() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoOPReq.q)
  return *q_;
}
inline void MongoOPReq::set_q(const ::std::string& value) {
  set_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_ = new ::std::string;
  }
  q_->assign(value);
  // @@protoc_insertion_point(field_set:dcorm.MongoOPReq.q)
}
inline void MongoOPReq::set_q(const char* value) {
  set_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_ = new ::std::string;
  }
  q_->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoOPReq.q)
}
inline void MongoOPReq::set_q(const char* value, size_t size) {
  set_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_ = new ::std::string;
  }
  q_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoOPReq.q)
}
inline ::std::string* MongoOPReq::mutable_q() {
  set_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    q_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dcorm.MongoOPReq.q)
  return q_;
}
inline ::std::string* MongoOPReq::release_q() {
  clear_has_q();
  if (q_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = q_;
    q_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MongoOPReq::set_allocated_q(::std::string* q) {
  if (q_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete q_;
  }
  if (q) {
    set_has_q();
    q_ = q;
  } else {
    clear_has_q();
    q_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoOPReq.q)
}

// optional string u = 2;
inline bool MongoOPReq::has_u() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MongoOPReq::set_has_u() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MongoOPReq::clear_has_u() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MongoOPReq::clear_u() {
  if (u_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    u_->clear();
  }
  clear_has_u();
}
inline const ::std::string& MongoOPReq::u() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoOPReq.u)
  return *u_;
}
inline void MongoOPReq::set_u(const ::std::string& value) {
  set_has_u();
  if (u_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    u_ = new ::std::string;
  }
  u_->assign(value);
  // @@protoc_insertion_point(field_set:dcorm.MongoOPReq.u)
}
inline void MongoOPReq::set_u(const char* value) {
  set_has_u();
  if (u_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    u_ = new ::std::string;
  }
  u_->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoOPReq.u)
}
inline void MongoOPReq::set_u(const char* value, size_t size) {
  set_has_u();
  if (u_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    u_ = new ::std::string;
  }
  u_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoOPReq.u)
}
inline ::std::string* MongoOPReq::mutable_u() {
  set_has_u();
  if (u_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    u_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dcorm.MongoOPReq.u)
  return u_;
}
inline ::std::string* MongoOPReq::release_u() {
  clear_has_u();
  if (u_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = u_;
    u_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MongoOPReq::set_allocated_u(::std::string* u) {
  if (u_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete u_;
  }
  if (u) {
    set_has_u();
    u_ = u;
  } else {
    clear_has_u();
    u_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoOPReq.u)
}

// optional string cmd = 3;
inline bool MongoOPReq::has_cmd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MongoOPReq::set_has_cmd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MongoOPReq::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MongoOPReq::clear_cmd() {
  if (cmd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmd_->clear();
  }
  clear_has_cmd();
}
inline const ::std::string& MongoOPReq::cmd() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoOPReq.cmd)
  return *cmd_;
}
inline void MongoOPReq::set_cmd(const ::std::string& value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
  // @@protoc_insertion_point(field_set:dcorm.MongoOPReq.cmd)
}
inline void MongoOPReq::set_cmd(const char* value) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoOPReq.cmd)
}
inline void MongoOPReq::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmd_ = new ::std::string;
  }
  cmd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoOPReq.cmd)
}
inline ::std::string* MongoOPReq::mutable_cmd() {
  set_has_cmd();
  if (cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dcorm.MongoOPReq.cmd)
  return cmd_;
}
inline ::std::string* MongoOPReq::release_cmd() {
  clear_has_cmd();
  if (cmd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cmd_;
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MongoOPReq::set_allocated_cmd(::std::string* cmd) {
  if (cmd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cmd_;
  }
  if (cmd) {
    set_has_cmd();
    cmd_ = cmd;
  } else {
    clear_has_cmd();
    cmd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoOPReq.cmd)
}

// optional .dcorm.MongoFindEx find = 4;
inline bool MongoOPReq::has_find() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MongoOPReq::set_has_find() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MongoOPReq::clear_has_find() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MongoOPReq::clear_find() {
  if (find_ != NULL) find_->::dcorm::MongoFindEx::Clear();
  clear_has_find();
}
inline const ::dcorm::MongoFindEx& MongoOPReq::find() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoOPReq.find)
  return find_ != NULL ? *find_ : *default_instance_->find_;
}
inline ::dcorm::MongoFindEx* MongoOPReq::mutable_find() {
  set_has_find();
  if (find_ == NULL) find_ = new ::dcorm::MongoFindEx;
  // @@protoc_insertion_point(field_mutable:dcorm.MongoOPReq.find)
  return find_;
}
inline ::dcorm::MongoFindEx* MongoOPReq::release_find() {
  clear_has_find();
  ::dcorm::MongoFindEx* temp = find_;
  find_ = NULL;
  return temp;
}
inline void MongoOPReq::set_allocated_find(::dcorm::MongoFindEx* find) {
  delete find_;
  find_ = find;
  if (find) {
    set_has_find();
  } else {
    clear_has_find();
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoOPReq.find)
}

// optional .dcorm.MongoRemoveEx remove = 5;
inline bool MongoOPReq::has_remove() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MongoOPReq::set_has_remove() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MongoOPReq::clear_has_remove() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MongoOPReq::clear_remove() {
  if (remove_ != NULL) remove_->::dcorm::MongoRemoveEx::Clear();
  clear_has_remove();
}
inline const ::dcorm::MongoRemoveEx& MongoOPReq::remove() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoOPReq.remove)
  return remove_ != NULL ? *remove_ : *default_instance_->remove_;
}
inline ::dcorm::MongoRemoveEx* MongoOPReq::mutable_remove() {
  set_has_remove();
  if (remove_ == NULL) remove_ = new ::dcorm::MongoRemoveEx;
  // @@protoc_insertion_point(field_mutable:dcorm.MongoOPReq.remove)
  return remove_;
}
inline ::dcorm::MongoRemoveEx* MongoOPReq::release_remove() {
  clear_has_remove();
  ::dcorm::MongoRemoveEx* temp = remove_;
  remove_ = NULL;
  return temp;
}
inline void MongoOPReq::set_allocated_remove(::dcorm::MongoRemoveEx* remove) {
  delete remove_;
  remove_ = remove;
  if (remove) {
    set_has_remove();
  } else {
    clear_has_remove();
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoOPReq.remove)
}

// -------------------------------------------------------------------

// MongoOPRsp

// optional int32 status = 1;
inline bool MongoOPRsp::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MongoOPRsp::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MongoOPRsp::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MongoOPRsp::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 MongoOPRsp::status() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoOPRsp.status)
  return status_;
}
inline void MongoOPRsp::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:dcorm.MongoOPRsp.status)
}

// optional string result = 2;
inline bool MongoOPRsp::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MongoOPRsp::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MongoOPRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MongoOPRsp::clear_result() {
  if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& MongoOPRsp::result() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoOPRsp.result)
  return *result_;
}
inline void MongoOPRsp::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_ = new ::std::string;
  }
  result_->assign(value);
  // @@protoc_insertion_point(field_set:dcorm.MongoOPRsp.result)
}
inline void MongoOPRsp::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_ = new ::std::string;
  }
  result_->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoOPRsp.result)
}
inline void MongoOPRsp::set_result(const char* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoOPRsp.result)
}
inline ::std::string* MongoOPRsp::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dcorm.MongoOPRsp.result)
  return result_;
}
inline ::std::string* MongoOPRsp::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MongoOPRsp::set_allocated_result(::std::string* result) {
  if (result_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_;
  }
  if (result) {
    set_has_result();
    result_ = result;
  } else {
    clear_has_result();
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoOPRsp.result)
}

// optional string error = 3;
inline bool MongoOPRsp::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MongoOPRsp::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MongoOPRsp::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MongoOPRsp::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& MongoOPRsp::error() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoOPRsp.error)
  return *error_;
}
inline void MongoOPRsp::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set:dcorm.MongoOPRsp.error)
}
inline void MongoOPRsp::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoOPRsp.error)
}
inline void MongoOPRsp::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoOPRsp.error)
}
inline ::std::string* MongoOPRsp::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dcorm.MongoOPRsp.error)
  return error_;
}
inline ::std::string* MongoOPRsp::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MongoOPRsp::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoOPRsp.error)
}

// -------------------------------------------------------------------

// MongoORM

// required .dcorm.MongoOP op = 1;
inline bool MongoORM::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MongoORM::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MongoORM::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MongoORM::clear_op() {
  op_ = 0;
  clear_has_op();
}
inline ::dcorm::MongoOP MongoORM::op() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoORM.op)
  return static_cast< ::dcorm::MongoOP >(op_);
}
inline void MongoORM::set_op(::dcorm::MongoOP value) {
  assert(::dcorm::MongoOP_IsValid(value));
  set_has_op();
  op_ = value;
  // @@protoc_insertion_point(field_set:dcorm.MongoORM.op)
}

// required string db = 2;
inline bool MongoORM::has_db() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MongoORM::set_has_db() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MongoORM::clear_has_db() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MongoORM::clear_db() {
  if (db_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    db_->clear();
  }
  clear_has_db();
}
inline const ::std::string& MongoORM::db() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoORM.db)
  return *db_;
}
inline void MongoORM::set_db(const ::std::string& value) {
  set_has_db();
  if (db_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    db_ = new ::std::string;
  }
  db_->assign(value);
  // @@protoc_insertion_point(field_set:dcorm.MongoORM.db)
}
inline void MongoORM::set_db(const char* value) {
  set_has_db();
  if (db_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    db_ = new ::std::string;
  }
  db_->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoORM.db)
}
inline void MongoORM::set_db(const char* value, size_t size) {
  set_has_db();
  if (db_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    db_ = new ::std::string;
  }
  db_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoORM.db)
}
inline ::std::string* MongoORM::mutable_db() {
  set_has_db();
  if (db_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    db_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dcorm.MongoORM.db)
  return db_;
}
inline ::std::string* MongoORM::release_db() {
  clear_has_db();
  if (db_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = db_;
    db_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MongoORM::set_allocated_db(::std::string* db) {
  if (db_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete db_;
  }
  if (db) {
    set_has_db();
    db_ = db;
  } else {
    clear_has_db();
    db_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoORM.db)
}

// optional string coll = 3;
inline bool MongoORM::has_coll() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MongoORM::set_has_coll() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MongoORM::clear_has_coll() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MongoORM::clear_coll() {
  if (coll_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coll_->clear();
  }
  clear_has_coll();
}
inline const ::std::string& MongoORM::coll() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoORM.coll)
  return *coll_;
}
inline void MongoORM::set_coll(const ::std::string& value) {
  set_has_coll();
  if (coll_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coll_ = new ::std::string;
  }
  coll_->assign(value);
  // @@protoc_insertion_point(field_set:dcorm.MongoORM.coll)
}
inline void MongoORM::set_coll(const char* value) {
  set_has_coll();
  if (coll_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coll_ = new ::std::string;
  }
  coll_->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoORM.coll)
}
inline void MongoORM::set_coll(const char* value, size_t size) {
  set_has_coll();
  if (coll_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coll_ = new ::std::string;
  }
  coll_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoORM.coll)
}
inline ::std::string* MongoORM::mutable_coll() {
  set_has_coll();
  if (coll_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coll_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dcorm.MongoORM.coll)
  return coll_;
}
inline ::std::string* MongoORM::release_coll() {
  clear_has_coll();
  if (coll_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = coll_;
    coll_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MongoORM::set_allocated_coll(::std::string* coll) {
  if (coll_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete coll_;
  }
  if (coll) {
    set_has_coll();
    coll_ = coll;
  } else {
    clear_has_coll();
    coll_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoORM.coll)
}

// optional .dcorm.MongoOPReq req = 4;
inline bool MongoORM::has_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MongoORM::set_has_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MongoORM::clear_has_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MongoORM::clear_req() {
  if (req_ != NULL) req_->::dcorm::MongoOPReq::Clear();
  clear_has_req();
}
inline const ::dcorm::MongoOPReq& MongoORM::req() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoORM.req)
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::dcorm::MongoOPReq* MongoORM::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::dcorm::MongoOPReq;
  // @@protoc_insertion_point(field_mutable:dcorm.MongoORM.req)
  return req_;
}
inline ::dcorm::MongoOPReq* MongoORM::release_req() {
  clear_has_req();
  ::dcorm::MongoOPReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void MongoORM::set_allocated_req(::dcorm::MongoOPReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoORM.req)
}

// optional .dcorm.MongoOPRsp rsp = 5;
inline bool MongoORM::has_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MongoORM::set_has_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MongoORM::clear_has_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MongoORM::clear_rsp() {
  if (rsp_ != NULL) rsp_->::dcorm::MongoOPRsp::Clear();
  clear_has_rsp();
}
inline const ::dcorm::MongoOPRsp& MongoORM::rsp() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoORM.rsp)
  return rsp_ != NULL ? *rsp_ : *default_instance_->rsp_;
}
inline ::dcorm::MongoOPRsp* MongoORM::mutable_rsp() {
  set_has_rsp();
  if (rsp_ == NULL) rsp_ = new ::dcorm::MongoOPRsp;
  // @@protoc_insertion_point(field_mutable:dcorm.MongoORM.rsp)
  return rsp_;
}
inline ::dcorm::MongoOPRsp* MongoORM::release_rsp() {
  clear_has_rsp();
  ::dcorm::MongoOPRsp* temp = rsp_;
  rsp_ = NULL;
  return temp;
}
inline void MongoORM::set_allocated_rsp(::dcorm::MongoOPRsp* rsp) {
  delete rsp_;
  rsp_ = rsp;
  if (rsp) {
    set_has_rsp();
  } else {
    clear_has_rsp();
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoORM.rsp)
}

// optional bytes cb = 6;
inline bool MongoORM::has_cb() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MongoORM::set_has_cb() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MongoORM::clear_has_cb() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MongoORM::clear_cb() {
  if (cb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cb_->clear();
  }
  clear_has_cb();
}
inline const ::std::string& MongoORM::cb() const {
  // @@protoc_insertion_point(field_get:dcorm.MongoORM.cb)
  return *cb_;
}
inline void MongoORM::set_cb(const ::std::string& value) {
  set_has_cb();
  if (cb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cb_ = new ::std::string;
  }
  cb_->assign(value);
  // @@protoc_insertion_point(field_set:dcorm.MongoORM.cb)
}
inline void MongoORM::set_cb(const char* value) {
  set_has_cb();
  if (cb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cb_ = new ::std::string;
  }
  cb_->assign(value);
  // @@protoc_insertion_point(field_set_char:dcorm.MongoORM.cb)
}
inline void MongoORM::set_cb(const void* value, size_t size) {
  set_has_cb();
  if (cb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cb_ = new ::std::string;
  }
  cb_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dcorm.MongoORM.cb)
}
inline ::std::string* MongoORM::mutable_cb() {
  set_has_cb();
  if (cb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cb_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:dcorm.MongoORM.cb)
  return cb_;
}
inline ::std::string* MongoORM::release_cb() {
  clear_has_cb();
  if (cb_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cb_;
    cb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MongoORM::set_allocated_cb(::std::string* cb) {
  if (cb_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cb_;
  }
  if (cb) {
    set_has_cb();
    cb_ = cb;
  } else {
    clear_has_cb();
    cb_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:dcorm.MongoORM.cb)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace dcorm

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dcorm::MongoOP> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dcorm::MongoOP>() {
  return ::dcorm::MongoOP_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mongo_2eproto__INCLUDED
